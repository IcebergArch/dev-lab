# JVM 

> 回答三个问题

## 什么是JVM
JVM（Java Virtual Machine）不是 Java 语言的一部分，而是一个“执行 Java 字节码的抽象计算机”。

它做三件核心事情：
- 定义一种中间指令体系（Bytecode）
- 提供一套运行时模型（内存、线程、GC、异常、类加载）
- 把中间指令映射到真实 CPU / OS 上执行

> 一句话总结：JVM 是“语言与操作系统之间的一层统一执行平台”。

## 为什么要JVM
回答这个问题可以通过有VM和没VM的场景对比进行

VM的核心价值在于 底层屏蔽，只要代码能转换为规范字节码就能确保在目标平台能正常运行

### 没有VM
优势
| 层级     | 抽象结论            |
| ------ | --------------- |
| 顶层结论   | 对执行路径与资源拥有完全主权  |
| 关键特征   | 直接机器码、无隐式运行时    |
| 直接能力   | 时间、内存、行为可预测     |
| 复杂性承担方 | 系统设计者 / 工程师     |
| 不可替代场景 | 实时系统、底层系统、性能极限  |
| 本质收益   | 以工程复杂度换取确定性与控制力 |

劣势
| 层级    | 抽象结论         |
| ----- | ------------ |
| 顶层结论  | 复杂性无法规模化     |
| 结构原因  | 无运行时兜底与统一模型  |
| 直接后果  | 人工保证正确性与安全   |
| 放大效应  | 规模扩大后问题指数增长  |
| 风险集中点 | 内存、并发、跨平台    |
| 本质代价  | 用团队能力对抗系统复杂度 |


### 有VM
优势
| 层级       | 抽象结论                    |
| -------- | ----------------------- |
| 顶层结论     | 通过运行时托管，使复杂系统可以规模化、长期演进 |
| 关键机制     | 统一执行模型 + 托管运行时 + 动态优化   |
| 解决的问题    | 平台差异、工程复杂性、长期维护成本       |
| 承担复杂性的一方 | 运行时（VM）                 |
| 适用系统形态   | 中大型系统、长期服务、多团队协作        |
| 本质收益     | 以不完全确定性，换取工程规模与演化能力     |

劣势
| 层级    | 抽象结论              |
| ----- | ----------------- |
| 顶层结论  | 牺牲执行确定性与边界控制      |
| 结构原因  | GC、调度、JIT 必然介入    |
| 直接结果  | 执行不可完全预测、资源不可精确控制 |
| 不可消除性 | 属于 VM 存在本身，而非实现缺陷 |
| 失效场景  | 硬实时、内核态、极端资源受限    |
| 本质代价  | 放弃对底层世界的完全主权      |


## 可不可以不要

JVM所做的事情可以改为自己处理：
代码可以直接编译为机器码
内存可以手动管理
并发可以自行实现
平台差异可以人工适配

但，对于长期运行的系统复杂性不回消失，只会转移

现存语言与VM关系
| 分类                  | 典型语言                                 | VM 的必要性      | 理由（抽象）                                                      |
| ------------------- | ------------------------------------ | ------------ | ----------------------------------------------------------- |
| **高度通用、高度动态、长期演化**  | Java, Kotlin, Scala, Clojure, Groovy | ✅ 必要         | 系统规模大、跨平台、团队协作、长期维护；VM 托管复杂性、提供 GC、JIT、类加载                  |
| **平台级通用、多语言共享运行时**  | C# / F# / VB.NET                     | ✅ 必要         | CLR 提供统一执行、内存管理、安全隔离，类似 JVM 理由                              |
| **脚本 / 动态语言**       | Python, Ruby, JS                     | ⚠️ 可选（通常 VM） | 语言动态性和易用性要求运行时，但理论上也可 AOT 编译（PyInstaller、Nuitka、GraalVM JS） |
| **系统 / 底层 / 高性能语言** | C, C++, Rust, Zig                    | ❌ 不要         | 追求确定性、硬件控制、低延迟，不需要 VM；复杂性交给工程师                              |
| **混合场景 / 选择型**      | Go, Swift, D, Nim                    | ⚠️ 通常不需要 VM  | 自带 runtime（调度器、GC），但没有完整 VM 抽象；可直接编译到机器码                    |
| **特殊 VM / 嵌入式 VM**  | Lua, Erlang                          | ⚠️ VM 轻量级    | 提供沙箱、协程、内存管理，但只为语言内部轻量抽象，非全平台通用 VM                          |

另外关于执行顺序的问题：
无VM语言，运行性能稳定，资源一定情况下其性能严格符合要求
有VM语言，运行性能基本稳定，资源一定情况下，其性能可能会有稍弱的波动


## JVM内容详解

jvm = class-loader + runtime-data-area + execution-engine，并通过 jni 与本地方法库交互

以一个类执行介绍jvm及各个场景的用途介绍

```java
// A.java
public static final main() {
    Obj obj = new Obj();
    obj.fun1();
    obj.fun2_nativate();
}
```

执行过程
```text
1. javac x.java
→ 生成 x.class

2. java x
→ JVM 启动
→ 创建 main 线程
→ 加载 x.class
→ 类元数据进入 Method Area
→ push main() 栈帧

3. 执行 main 方法
→ new obj()
  - 加载 obj.class
  - obj 类信息进入 Method Area
  - 对象实例分配在 Heap
  - 引用存入 main 栈帧

→ 调用 obj.fun1()
  - fun1 栈帧 push 到 Java Stack
  - 执行完成后 pop

→ 调用 obj.fun2_native()
  - native 方法栈帧 push 到 Java Stack
  - 通过 JNI 使用 Native Method Stack
  - 本地方法执行完成
  - Native Stack pop
  - Java Stack pop

4. main 方法结束
→ main 栈帧 pop
→ main 线程结束

5. JVM 检查非 daemon 线程
→ 无 → JVM 退出
→ OS 回收资源

```

栈帧：


类加载：
加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 销毁
链接：
- 验证是否合法、对jvm有威胁
- 准备常量空间申请
- 将类的相关熟悉空间关联，引用等替换为实际链接

osGi热部署